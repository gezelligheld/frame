#### stack reconciler

v16之前，渲染核心算法称之为Stack reconciler

react在进行组件渲染时，从setState开始到渲染完成整个过程是同步的，如果需要渲染的组件比较庞大，js执行会占据主线程时间较长，会导致页面响应度变差，出现卡顿

Stack reconciler的工作流程很像函数的调用过程。父组件里调子组件，可以类比为函数的递归。在setState后，react会立即开始reconciliation过程，从父节点（Virtual DOM）开始遍历，以找出不同。将所有的Virtual DOM遍历完成后，reconciler才能给出当前需要修改真实DOM的信息，并传递给renderer，进行渲染，然后屏幕上才会显示此次更新内容

#### fiber reconciler

对于函数来说，这没什么问题，因为我们只想要函数的运行结果，但对于UI来说还需要考虑以下问题:

- 并不是所有的state更新都需要立即显示出来，比如屏幕之外的部分的更新

- 并不是所有的更新优先级都是一样的

- 对于某些高优先级的操作，应该是可以打断低优先级的操作执行的

fiber-reconciler下，操作是可以分成很多小部分，并且可以被中断的，fiber对象表征reconciliation阶段所能拆分的最小工作单元，整个结构是一个链表树。每个工作单元（fiber）执行完成后，都会查看是否还继续拥有主线程时间片，如果有继续下一个，如果没有则先处理其他高优先级事务，等主线程空闲下来继续执行

简单来说，每次只做一个很小的任务，做完后能够“喘口气儿”，回到主线程看下有没有什么更高优先级的任务需要处理，如果又则先处理更高优先级的任务，没有则继续执行