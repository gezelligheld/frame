mobx同redux一样是独立的，不依赖于react本身，其他框架也可以使用

#### 基本用法

![image](https://cn.mobx.js.org/flow.png)

示例如下

```js
import { observer } from 'mobx-react';
import { makeAutoObservable, makeObservable, observable, action, computed, flow } from 'mobx';

class AttributeData {
  data = '';

  constructor(defaultValue?: string) {
    makeAutoObservable(this);
    // 或者
    // makeObservable(this, {
    //   data: observable,
    //   setData: action,
    //   confirm: action,
    //   isValidData: computed,
    // });
    this.data = defaultValue || '';
  }

  setData = (value: string) => {
    this.data = value;
  };

  confirm = () => {
    return Promise.resolve(this.data);
  };

  get isValidData() {
    return this.data > 5;
  }
}

const Page = observer(() => {
  const model = useMemo(() => new AttributeData(), []);
  // todo
})
```

以下是mobx常用的api

- makeAutoObservable / makeObservable

让整个模块变成可响应式的，可以取代之前的装饰器写法，其中makeAutoObservable会自动将变量标记为observable，普通函数标记为action，生成器函数标记为flow，getter标记为computed，如有特殊情况使用makeObservable依次指定

- observable

使其成为可观察的，当其改变的时候，观察者会通知每个依赖项

- action

action标记的函数用来修改mobx的状态

- computed

用于标记getter

- flow

用于标记生成器函数，用来处理异步的状态改变

以下是mobx-react常用的api

- Provider && inject

Provider将mobx的数据以context上下文的形式保存，inject可以将其注入到组件props中（实践较少）

- observer

被 observer 高阶组件包装的组件，如果组件内部引入了 mobx 可观察属性值，当值改变的时候，会追溯到当前组件，促使当前组件更新

- autorun

接收一个函数，当这个函数中依赖的可观察属性发生变化的时候，autorun 里面的函数就会被触发，该函数在第一次会立即执行一次

```js
const person = observable({
    age: 20
}) 
// autorun 里面的函数会立即执行一次，当 age 变化的时候会再次执行一次
autorun(() => {
    console.log("age", person.age);
})
person.age = 21;
// 输出：
// age 20
// age 21
```

- reaction

可以在监听到指定数据变化的时候执行一些操作，类似于vue的watch

```js
// 当todos改变的时候将其存入缓存
reaction(
    () => toJS(this.todos),
    (todos) =>  localStorage.setItem('mobx-react-todomvc-todos', JSON.stringify({ todos }))
)
```

#### 原理

和vue类似，分为以下几步

1. 用Proxy拦截observable包装的对象属性的get/set

2. 在 autorun 或者 reaction 执行的时候，会触发依赖状态的 get，将autorun或reaction中要执行的函数与依赖的状态关联起来，进行依赖收集

3. 当修改状态时触发set，将触发所关联的函数执行

参考
1. (各流派 React 状态管理对比和原理实现)[https://github.com/yinguangyao/blog/issues/56]