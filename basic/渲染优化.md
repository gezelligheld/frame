对于react渲染，组件本身执行，从调度更新任务到调和fiber，再到浏览器渲染真实dom，每个环节react底层都做了大量的优化，如更新任务优先级、异步调度、diff算法、时间分片、批量更新等，作为开发者只需要告知哪些组件需要更新，哪些不需要更新即可

对于更新fiber流程的render阶段（对于类组件是执行render函数，对于函数组件是执行函数组件本身），是根据一次更新中产生的新的状态，得到最新的React element 对象，不存在任何副作用，react提供了几种控制render的方法，究其本质主要为两种

- 从父组件直接隔断子组件的渲染

- 从组件自身判断是否渲染

#### 缓存React.element对象

对 React.element 对象缓存，是父组件对子组件的渲染控制，也就是父组件某些状态的更新并不需要引起子组件的重新渲染

如下，无论改变numberA还是numberB都会引起子组件的重新渲染

```js
function Children ({ number }){
    console.log('子组件渲染')
    return <div>let us learn React!  { number } </div>
}
class Index extends React.Component{
    state={
        numberA:0,
        numberB:0,
    }
    render(){
        return <div>
            <Children number={ this.state.numberA } />
           <button onClick={ ()=> this.setState({ numberA:this.state.numberA + 1 }) } >改变numberA -{ this.state.numberA } </button>
           <button onClick={ ()=> this.setState({ numberB:this.state.numberB + 1 }) } >改变numberB -{ this.state.numberB }</button>
        </div>
     }
}
```

我们期望只有numberA变化的时候才触发子组件的重新渲染，故对父组件修改如下

```js
class Index extends React.Component{
    constructor(props){
        super(props)
        this.state={
            numberA:0,
            numberB:0,
        }
        this.component =  <Children number={this.state.numberA} />
    }
    controllComponentRender=()=>{ /* 通过此函数判断 */
        const { props } = this.component
        if(props.number !== this.state.numberA ){ /* 只有 numberA 变化的时候，重新创建 element 对象  */
            return this.component = React.cloneElement(this.component,{ number:this.state.numberA })
        }
        return this.component
    }
    render(){
       return <div>
          { this.controllComponentRender()  } 
          <button onClick={ ()=> this.setState({ numberA:this.state.numberA + 1 }) } >改变numberA</button>
          <button onClick={ ()=> this.setState({ numberB:this.state.numberB + 1 }) }  >改变numberB</button>
       </div>
    }
}
```

如果是函数组件，可以用useMemo达到这样的效果

```js
function Index(){
    const [ numberA , setNumberA ] = React.useState(0)
    const [ numberB , setNumberB ] = React.useState(0)
    return <div>
        { useMemo(()=> <Children number={numberA} />,[ numberA ]) }
        <button onClick={ ()=> setNumberA(numberA + 1) } >改变numberA</button>
        <button onClick={ ()=> setNumberB(numberB + 1) } >改变numberB</button>
    </div>
}
```

究其本质，每次执行render都会产生一个新的props，在fiber更新的时候，会对新旧props进行比较，如果一致会停止子组件的调和更新，缓存了element对象后，新旧props指向相同的内存空间，就不会有多余的渲染

#### PureComponent

PureComponent会浅比较state 和 props 是否相等，浅比较意味着如果是引用类型，前后指向同一个内存空间，会被判为相等，不会引起渲染

```js
class Children extends React.PureComponent{
    state={
        name:'alien',
        age:18,
        obj:{
            number:1,
        }
    }
    changeObjNumber=()=>{
        const { obj } = this.state
        obj.number++
        this.setState({ obj })
    }
    render(){
        console.log('组件渲染')
        return <div  >
           <div> 组件本身改变state </div>
           <button onClick={() => this.setState({ name:'alien' }) } >state相同情况</button>
           <button onClick={() => this.setState({ age:this.state.age + 1  }) }>state不同情况</button>
           <button onClick={ this.changeObjNumber } >state为引用数据类型时候</button>
           <div>hello,my name is alien,let us learn React!</div>
        </div>
    }
}
/* 父组件 */
export default function Home (){
    const [ numberA , setNumberA ] = React.useState(0)
    const [ numberB , setNumberB ] = React.useState(0)
    return <div>
        <div> 父组件改变props </div>
        <button onClick={ ()=> setNumberA(numberA + 1) } >改变numberA</button>
        <button onClick={ ()=> setNumberB(numberB + 1) } >改变numberB</button>
        <Children number={numberA}  /> 
    </div>
}
```

继承PureComponent后，在更新组件时会检查是否需要进行更新

```js
function checkShouldComponentUpdate(){
     if (typeof instance.shouldComponentUpdate === 'function') {
         return instance.shouldComponentUpdate(newProps,newState,nextContext)  /* shouldComponentUpdate 逻辑 */
     }
    if (ctor.prototype && ctor.prototype.isPureReactComponent) {
        return  !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState)
    }
}
```

shallowEqual比较的过程如下

1. 比较新旧state或props是否相等，如果相等则不更新
2. 判断新旧state或props存在不为对象或为null的，返回false，更新组件
3. 通过Object.keys判断新旧state或props的属性有没有增减，如果有变化则更新组件
4. 遍历新旧state或props，看是否对应相等（浅比较），如果有一个不相等则更新组件

#### shouldComponentUpdate

shouldComponentUpdate可以根据新的状态和旧的状态，来决定是否进行更新

```js
class Index extends React.Component{ //子组件
    state={
        stateNumA:0,
        stateNumB:0
    }
    shouldComponentUpdate(newProp,newState,newContext){
        if(newProp.propsNumA !== this.props.propsNumA || newState.stateNumA !== this.state.stateNumA ){
            // 只有当 props 中 propsNumA 和 state 中 stateNumA 变化时，更新组件
            return true
        }
        return false 
    }
    render(){
        console.log('组件渲染')
        const { stateNumA ,stateNumB } = this.state
        return <div>
            <button onClick={ ()=> this.setState({ stateNumA: stateNumA + 1 }) } >改变state中numA</button>
            <button onClick={ ()=> this.setState({ stateNumB: stateNumB + 1 }) } >改变stata中numB</button>
            <div>hello,let us learn React!</div>
        </div>
    }
}
export default function Home(){ // 父组件
    const [ numberA , setNumberA ] = React.useState(0)
    const [ numberB , setNumberB ] = React.useState(0)
    return <div>
        <button onClick={ ()=> setNumberA(numberA + 1) } >改变props中numA</button>
        <button onClick={ ()=> setNumberB(numberB + 1) } >改变props中numB</button>
        <Index propsNumA={numberA}  propsNumB={numberB}   />
    </div>
}
```

#### React.memo

浅比较props

```js
// 第二个参数可选，返回true组件渲染，否则不渲染；不传时默认浅比较
React.memo(Component,compare)
```

示例如下

```js
function TextMemo(props){
    console.log('子组件渲染')
    return <div>hello,world</div> 
}
const controlIsRender = (pre,next)=>{
    // number不改变或number 改变但值大于5->不渲染组件 | 否则渲染组件
   return ( pre.number === next.number ) ||  (pre.number !== next.number && next.number > 5)
}
const NewTexMemo = memo(TextMemo,controlIsRender)
class Index extends React.Component{
    constructor(props){
        super(props)
        this.state={
            number:1,
            num:1
        }
    }
    render(){
        const { num , number }  = this.state
        return <div>
            <div>
                改变num：当前值 { num }
                <button onClick={ ()=>this.setState({ num:num + 1 }) } >num++</button>
                <button onClick={ ()=>this.setState({ num:num - 1 }) } >num--</button>  
            </div>
            <div>
                改变number： 当前值 { number }
                <button onClick={ ()=>this.setState({ number:number + 1 }) } > number ++</button>
                <button onClick={ ()=>this.setState({ number:number - 1 }) } > number -- </button>  
            </div>
            <NewTexMemo num={ num } number={number}  />
        </div>
    }
}
```

被 memo 包裹的组件，element 会被打成 REACT_MEMO_TYPE 类型的 element 标签，在 element 变成 fiber 的时候， fiber 会被标记成 MemoComponent 的类型，此类型的fiber有单独的更新处理逻辑updateMemoComponent

```js
function updateMemoComponent(){
    if (updateExpirationTime < renderExpirationTime) {
         let compare = Component.compare;
         compare = compare !== null ? compare : shallowEqual //如果 memo 有第二个参数，则用二个参数判定，没有则浅比较props是否相等。
        if (compare(prevProps, nextProps) && current.ref === workInProgress.ref) {
            return bailoutOnAlreadyFinishedWork(current,workInProgress,renderExpirationTime); //已经完成工作停止向下调和节点。
        }
    }
    // 返回将要更新组件,memo包装的组件对应的fiber，继续向下调和更新。
}
```

综上，当状态变化时，如果缓存了element对象，直接退出更新流程，否则向下调和子节点。如果采用了memo缓存策略，就对props进行浅比较（有compare就根据compare的规则进行比较）。之后如果是函数组件，会根据shouldComponentUpdate的返回值决定是否进行更新，然后如果是PureComponent会作浅比较决定是否进行更新

!()[https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3df03000a39549bead3c84750c62576c~tplv-k3u1fbpfcp-watermark.awebp]

一般情况下，不需要过分在意react多余的render，执行render并不意味着浏览器渲染视图，而且diff也可以差异更新，但有时多余的render可能带来额外的问题，如作为useEffect依赖、渲染成本较高的组件等，就需要具体情况具体分析了