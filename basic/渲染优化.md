对于react渲染，组件本身执行，从调度更新任务到调和fiber，再到浏览器渲染真实dom，每个环节react底层都做了大量的优化，如更新任务优先级、异步调度、diff算法、时间分片、批量更新等，作为开发者只需要告知哪些组件需要更新，哪些不需要更新即可

对于更新fiber流程的render阶段（对于类组件是执行render函数，对于函数组件是执行函数组件本身），是根据一次更新中产生的新的状态，得到最新的React element 对象，不存在任何副作用，react提供了几种控制render的方法，究其本质主要为两种

- 从父组件直接隔断子组件的渲染

- 从组件自身判断是否渲染

#### 缓存React.element对象

对 React.element 对象缓存，是父组件对子组件的渲染控制，也就是父组件某些状态的更新并不需要引起子组件的重新渲染

如下，无论改变numberA还是numberB都会引起子组件的重新渲染

```js
function Children ({ number }){
    console.log('子组件渲染')
    return <div>let us learn React!  { number } </div>
}
class Index extends React.Component{
    state={
        numberA:0,
        numberB:0,
    }
    render(){
        return <div>
            <Children number={ this.state.numberA } />
           <button onClick={ ()=> this.setState({ numberA:this.state.numberA + 1 }) } >改变numberA -{ this.state.numberA } </button>
           <button onClick={ ()=> this.setState({ numberB:this.state.numberB + 1 }) } >改变numberB -{ this.state.numberB }</button>
        </div>
     }
}
```

我们期望只有numberA变化的时候才触发子组件的重新渲染，故对父组件修改如下

```js
class Index extends React.Component{
    constructor(props){
        super(props)
        this.state={
            numberA:0,
            numberB:0,
        }
        this.component =  <Children number={this.state.numberA} />
    }
    controllComponentRender=()=>{ /* 通过此函数判断 */
        const { props } = this.component
        if(props.number !== this.state.numberA ){ /* 只有 numberA 变化的时候，重新创建 element 对象  */
            return this.component = React.cloneElement(this.component,{ number:this.state.numberA })
        }
        return this.component
    }
    render(){
       return <div>
          { this.controllComponentRender()  } 
          <button onClick={ ()=> this.setState({ numberA:this.state.numberA + 1 }) } >改变numberA</button>
          <button onClick={ ()=> this.setState({ numberB:this.state.numberB + 1 }) }  >改变numberB</button>
       </div>
    }
}
```

如果是函数组件，可以用useMemo达到这样的效果

```js
function Index(){
    const [ numberA , setNumberA ] = React.useState(0)
    const [ numberB , setNumberB ] = React.useState(0)
    return <div>
        { useMemo(()=> <Children number={numberA} />,[ numberA ]) }
        <button onClick={ ()=> setNumberA(numberA + 1) } >改变numberA</button>
        <button onClick={ ()=> setNumberB(numberB + 1) } >改变numberB</button>
    </div>
}
```

究其本质，每次执行render都会产生一个新的props，在fiber更新的时候，会对新旧props进行比较，如果一致会停止子组件的调和更新，缓存了element对象后，新旧props指向相同的内存空间，就不会有多余的渲染

#### PureComponent

#### shouldComponentUpdate

#### React.memo